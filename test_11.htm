<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anilibria player</title>
    <!-- Подключаем Video.js стили -->
    <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }
        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
            gap: 10px;
        }
        .video-container {
            flex: 3;
            background-color: #2c2c2c;
            border-radius: 5px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            overflow: hidden;
            max-height: 100vh;
        }
        .video-js {
            width: 100%;
            max-height: 100vh;
            height: auto;
        }
        .video-js .vjs-control-bar {
            font-size: 14px;
            background-color: #2c2c2c;
            position: absolute;
            bottom: 0;
            width: 100%;
        }
        .episodes-list {
            flex: 1;
            height: 100%;
            overflow-y: auto;
            background-color: #2c2c2c;
            padding: 10px;
            border-radius: 5px;
        }
        .episode-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        .episode-item:hover {
            background-color: #3a3a3a;
        }
        .episode-item img {
            width: 80px;
            height: 45px;
            object-fit: cover;
            margin-right: 10px;
            border-radius: 3px;
        }
        .episode-item span {
            font-size: 14px;
            color: #e0e0e0;
        }
        .video-js .vjs-big-play-button {
            background-color: rgba(0, 0, 0, 0.7);
            border-color: #ffffff;
        }
        .video-js .vjs-play-progress,
        .video-js .vjs-volume-level {
            background-color: #1e90ff;
        }
        .video-js .vjs-slider {
            background-color: #555555;
        }
        .vjs-quality-menu {
            position: relative;
            display: inline-block;
        }
        .vjs-quality-menu .vjs-menu-button {
            cursor: pointer;
            color: #ffffff;
        }
        .vjs-quality-menu .vjs-thinking-indicator {
            display: none;
        }
        .vjs-quality-menu .vjs-menu {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #2c2c2c;
            color: #ffffff;
            border-radius: 4px;
            z-index: 100;
            border: 1px solid #444444;
        }
        .vjs-quality-menu:hover .vjs-menu {
            display: block;
        }
        .vjs-quality-menu .vjs-menu li {
            padding: 8px 16px;
            cursor: pointer;
            list-style: none;
            font-size: 12px;
        }
        .vjs-quality-menu .vjs-menu li:hover {
            background: #3a3a3a;
        }
        .vjs-quality-menu .vjs-selected {
            font-weight: bold;
            background: #1e90ff;
        }
        .error-message {
            color: #ff5555;
            text-align: center;
            padding: 10px;
        }
        /* Стили для модального окна */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: #2c2c2c;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            color: #ffffff;
            max-width: 400px;
        }
        .modal-content p {
            margin: 0 0 20px;
        }
        .modal-content button {
            padding: 10px 20px;
            margin: 0 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            background: #1e90ff;
            color: #ffffff;
        }
        .modal-content button.cancel {
            background: #555555;
        }
        /* Стили для кнопок пропуска заставок */
        .vjs-skip-button {
            display: none;
            cursor: pointer;
            color: #ffffff;
            padding: 0 10px;
        }
        .vjs-skip-button.vjs-visible {
            display: inline-block;
        }
        @media (min-aspect-ratio: 21/9) {
            .video-js {
                max-height: 90vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-container">
            <!-- Контейнер для плеера -->
            <video-js id="my-video" class="video-js vjs-default-skin" controls preload="auto">
                <p class="vjs-no-js">
                    Для просмотра видео включите JavaScript и используйте браузер, поддерживающий HTML5 видео.
                </p>
            </video-js>
        </div>
        <div class="episodes-list" id="episodes-list">
            <!-- Список серий будет добавлен динамически -->
        </div>
    </div>

    <!-- Модальное окно для продолжения воспроизведения -->
    <div class="modal" id="continue-modal">
        <div class="modal-content">
            <p id="continue-message"></p>
            <button id="continue-btn">Продолжить</button>
            <button id="cancel-btn" class="cancel">Начать сначала</button>
        </div>
    </div>

    <!-- Подключаем Video.js -->
    <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
    <!-- Подключаем плагин плейлиста -->
    <script src="https://unpkg.com/videojs-playlist@4.3.1/dist/videojs-playlist.min.js"></script>
    <script>
        // Инициализация плеера
        const player = videojs('my-video', {
            fluid: true,
            responsive: true,
            playbackRates: [0.5, 1, 1.5, 2],
            html5: {
                vhs: {
                    overrideNative: true
                }
            }
        });

        // Функция для создания кастомного меню качества
        function createQualityMenu(player, qualities, currentQuality) {
            const controlBar = player.controlBar.el();
            const qualityMenu = document.createElement('div');
            qualityMenu.className = 'vjs-quality-menu vjs-control';

            const button = document.createElement('div');
            button.className = 'vjs-menu-button vjs-control';
            button.innerHTML = `<span>Качество: ${currentQuality}</span>`;
            qualityMenu.appendChild(button);

            const menu = document.createElement('ul');
            menu.className = 'vjs-menu';
            qualities.forEach(quality => {
                const li = document.createElement('li');
                li.innerText = quality.label;
                if (quality.label === currentQuality) {
                    li.className = 'vjs-selected';
                }
                li.addEventListener('click', () => {
                    player.src({ src: quality.src, type: 'application/x-mpegURL' });
                    button.innerHTML = `<span>${currentQuality}</span>`;
                    menu.querySelectorAll('li').forEach(item => item.className = '');
                    li.className = 'vjs-selected';
                    player.play();
                });
                menu.appendChild(li);
            });
            qualityMenu.appendChild(menu);

            const settingsButton = controlBar.querySelector('.vjs-settings-control') || controlBar.lastChild;
            controlBar.insertBefore(qualityMenu, settingsButton);
        }

        // Функции для работы с localStorage
        function saveProgress(animeId, episodeIndex, currentTime) {
            let progress = JSON.parse(localStorage.getItem('animeProgress') || '{}');
            progress[animeId] = { episodeIndex, currentTime };
            localStorage.setItem('animeProgress', JSON.stringify(progress));
        }

        function getProgress(animeId) {
            const progress = JSON.parse(localStorage.getItem('animeProgress') || '{}');
            return progress[animeId] || null;
        }

        // Функция для показа модального окна
        function showContinueModal(episodeIndex, currentTime, episodeName) {
            const modal = document.getElementById('continue-modal');
            const message = document.getElementById('continue-message');
            const continueBtn = document.getElementById('continue-btn');
            const cancelBtn = document.getElementById('cancel-btn');

            message.textContent = `Продолжить "${episodeName}" с ${Math.floor(currentTime / 60)}:${Math.floor(currentTime % 60).toString().padStart(2, '0')}?`;
            modal.style.display = 'flex';

            continueBtn.onclick = () => {
                player.playlist.currentItem(episodeIndex);
                player.currentTime(currentTime);
                player.play();
                modal.style.display = 'none';
            };

            cancelBtn.onclick = () => {
                player.playlist.currentItem(episodeIndex);
                player.currentTime(0);
                player.play();
                modal.style.display = 'none';
            };
        }

        // Функция для создания кнопок пропуска заставок
        function createSkipButtons(player, opening, ending) {
            const controlBar = player.controlBar.el();

            // Кнопка пропуска опенинга
            const skipOpeningButton = document.createElement('div');
            skipOpeningButton.className = 'vjs-skip-button vjs-control';
            skipOpeningButton.innerText = 'Пропустить опенинг';
            skipOpeningButton.addEventListener('click', () => {
                if (opening && opening.stop) {
                    player.currentTime(opening.stop);
                }
            });

            // Кнопка пропуска эндинга
            const skipEndingButton = document.createElement('div');
            skipEndingButton.className = 'vjs-skip-button vjs-control';
            skipEndingButton.innerText = 'Пропустить эндинг';
            skipEndingButton.addEventListener('click', () => {
                if (ending && ending.stop) {
                    player.currentTime(ending.stop);
                }
            });

            // Вставляем кнопки перед меню качества
            const qualityMenu = controlBar.querySelector('.vjs-quality-menu') || controlBar.lastChild;
            controlBar.insertBefore(skipOpeningButton, qualityMenu);
            controlBar.insertBefore(skipEndingButton, qualityMenu);

            return { skipOpeningButton, skipEndingButton };
        }

        // Функция для обновления видимости кнопок пропуска
        function updateSkipButtons(currentTime, opening, ending, buttons) {
            if (opening && opening.start && opening.stop && currentTime >= opening.start && currentTime < opening.stop) {
                buttons.skipOpeningButton.classList.add('vjs-visible');
            } else {
                buttons.skipOpeningButton.classList.remove('vjs-visible');
            }

            if (ending && ending.start && ending.stop && currentTime >= ending.start && currentTime < ending.stop) {
                buttons.skipEndingButton.classList.add('vjs-visible');
            } else {
                buttons.skipEndingButton.classList.remove('vjs-visible');
            }
        }

        // Функция для загрузки данных и создания плейлиста
        async function loadPlaylist(animeId) {
            try {
                const response = await fetch(`https://anilibria.top/api/v1/anime/releases/${animeId}`);
                if (!response.ok) {
                    throw new Error(`Ошибка API: ${response.status}`);
                }
                const data = await response.json();

                if (!data?.episodes?.length) {
                    throw new Error('Эпизоды не найдены');
                }

                // Формируем плейлист
                const playlist = data.episodes.map((episode, index) => {
                    return {
                        sources: [
                            { src: episode.hls_1080, type: 'application/x-mpegURL', label: '1080p' },
                            { src: episode.hls_720, type: 'application/x-mpegURL', label: '720p' },
                            { src: episode.hls_480, type: 'application/x-mpegURL', label: '480p' }
                        ].filter(source => source.src),
                        poster: `https://anilibria.top${episode.preview.src}`,
                        name: `${index+1} ${episode.name}`,
                        thumbnail: `https://anilibria.top${episode.preview.src}`,
                        opening: episode.opening || null,
                        ending: episode.ending || null
                    };
                });

                // Инициализируем плейлист
                player.playlist(playlist);
                player.playlist.autoadvance(0);

                // Создаём кастомное меню качества для первой серии
                const firstEpisode = playlist[0];
                if (firstEpisode.sources.length > 0) {
                    createQualityMenu(player, firstEpisode.sources, firstEpisode.sources[0].label);
                }

                // Проверяем прогресс для аниме
                const savedProgress = getProgress(animeId);
                if (savedProgress && savedProgress.currentTime > 5) {
                    showContinueModal(savedProgress.episodeIndex, savedProgress.currentTime, playlist[savedProgress.episodeIndex].name);
                } else {
                    player.play();
                }

                // Создаём кнопки пропуска заставок
                let skipButtons = createSkipButtons(player, firstEpisode.opening, firstEpisode.ending);

                // Обновляем меню качества, кнопки пропуска и проверяем прогресс при смене серии
                player.on('playlistitem', () => {
                    const currentItem = player.playlist.currentItem();
                    const currentEpisode = playlist[currentItem];
                    if (currentEpisode.sources.length > 0) {
                        const qualityMenu = player.controlBar.el().querySelector('.vjs-quality-menu');
                        if (qualityMenu) qualityMenu.remove();
                        createQualityMenu(player, currentEpisode.sources, currentEpisode.sources[0].label);
                    }
                    // Обновляем кнопки пропуска
                    const oldSkipButtons = player.controlBar.el().querySelectorAll('.vjs-skip-button');
                    oldSkipButtons.forEach(btn => btn.remove());
                    skipButtons = createSkipButtons(player, currentEpisode.opening, currentEpisode.ending);
                    // Проверяем прогресс
                    const savedProgress = getProgress(animeId);
                    if (savedProgress && savedProgress.episodeIndex === currentItem && savedProgress.currentTime > 5) {
                        showContinueModal(savedProgress.episodeIndex, savedProgress.currentTime, currentEpisode.name);
                    }
                });

                // Сохраняем прогресс и обновляем видимость кнопок пропуска
                player.on('timeupdate', () => {
                    const currentItem = player.playlist.currentItem();
                    const currentTime = player.currentTime();
                    if (currentTime > 5) {
                        saveProgress(animeId, currentItem, currentTime);
                    }
                    const currentEpisode = playlist[currentItem];
                    updateSkipButtons(currentTime, currentEpisode.opening, currentEpisode.ending, skipButtons);
                });

                // Создаём список серий с превью
                const episodesList = document.getElementById('episodes-list');
                episodesList.innerHTML = '';
                playlist.forEach((episode, index) => {
                    const episodeItem = document.createElement('div');
                    episodeItem.className = 'episode-item';
                    episodeItem.innerHTML = `
                        <img src="${episode.thumbnail}" alt="${episode.name}" loading="lazy">
                        <span>${episode.name}</span>
                    `;
                    episodeItem.addEventListener('click', () => {
                        player.playlist.currentItem(index);
                        player.play();
                    });
                    episodesList.appendChild(episodeItem);
                });
            } catch (error) {
                console.error('Ошибка загрузки плейлиста:', error);
                const episodesList = document.getElementById('episodes-list');
                episodesList.innerHTML = '<p class="error-message">Ошибка загрузки данных. Проверьте соединение или API.</p>';
            }
        }

        // Загружаем плейлист для animeId = 9217
        function getParam(get) {
      const params = new URLSearchParams(window.location.search);
      return params.get(get);
    }
        loadPlaylist(getParam("id")||9217);
    </script>
</body>
</html>